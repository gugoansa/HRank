üë∂ Explicaci√≥n Nivel Beb√©: El Detective de Elementos
Imagina que la p√°gina web es un cuarto lleno de juguetes (botones, campos de texto, im√°genes). Tu misi√≥n como automatizador es decirle a Playwright (el Detective) d√≥nde est√° el juguete que debe usar.

Un Localizador es la direcci√≥n exacta que le das al Detective.

Mal Detective (Sin Localizador): "Haz clic en el bot√≥n." (‚ùå Playwright no sabe cu√°l).

Buen Detective (Con Localizador): "Haz clic en el bot√≥n que est√° etiquetado como 'Enviar' y tiene el n√∫mero de identificaci√≥n 'login-btn'." (‚úÖ Playwright lo encuentra sin dudar).

Si le das una direcci√≥n ambigua, Playwright podr√≠a hacer clic en el juguete equivocado, y tu prueba fallar√°.

üíª Tipos de Localizadores en Playwright (La Realidad)
En Playwright, siempre se usa el m√©todo page.locator() para empezar, y dentro de √©l, se usan diferentes tipos de selectores. Playwright recomienda priorizar los selectores basados en Roles y Texto antes de usar selectores basados en la estructura del HTML (como CSS o XPath).

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

1. ü•á Localizadores Basados en Roles (¬°La Mejor Opci√≥n!)
Estos le dicen al Detective qu√© tipo de elemento es, bas√°ndose en lo que ve el usuario o las herramientas de accesibilidad.

Tipo    	¬øQu√© le dices al Detective?	                                            Ejemplo de Uso
getByRole	"Busca un bot√≥n que se llama 'Enviar'."	                                page.getByRole('button', { name: 'Enviar' })
getByText	"Busca un elemento que contenga el texto exacto 'Finalizar Compra'."	page.getByText('Finalizar Compra')
getByLabel	"Busca el campo de entrada que tiene una etiqueta 'Usuario'."	        page.getByLabel('Usuario')

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

2. ü•à Localizadores Basados en HTML (Selectores CSS)
Si los roles no funcionan, usamos la direcci√≥n espec√≠fica que viene del c√≥digo HTML. CSS es el m√°s r√°pido y com√∫n.

Tipo	        ¬øQu√© le dices al Detective?	                                    Ejemplo de Uso
Por ID	        "Busca el elemento con el n√∫mero de identificaci√≥n 'myId'."	    page.locator('#myId')
Por Clase	    "Busca todos los elementos con la clase 'item-card'."	        page.locator('.item-card')
Por Atributo	"Busca el elemento que tenga el atributo data-testid='login'."	page.locator('[data-testid="login"]')

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

2.1 **** pseudocode - pseudoclase ****
 Es una forma de describir un algoritmo o una serie de pasos l√≥gicos de manera simple, utilizando una mezcla de lenguaje natural y convenciones de programaci√≥n.
 se usa Para planificar la l√≥gica de un programa antes de escribirlo en un lenguaje de programaci√≥n real (como Python, JavaScript o C++). No se ejecuta en ning√∫n software.
Contexto: Se usa en la programaci√≥n, en la etapa de dise√±o, y no tiene nada que ver con CSS.

tr:not(:first-child)  //recupera cada fila de la tabla sin los cabeceros
  :nth-child(n)       //Selecciona el en√©simo hijo de un elemento padre. Puedes usar f√≥rmulas para selecciones m√°s complejas.
tr:nth-child(n+2)     //Selecciona todas las filas a partir de la segunda (excluyendo la primera).
tr + tr:              //Selecciona cada elemento <tr> que es inmediatamente precedido por otro <tr>. Esto tambi√©n excluir√° el primer <tr>.
  :not(:last-child)   //Selecciona todos los elementos excepto el √∫ltimo. Si lo usas junto a :not(:first-child), puedes seleccionar todos los elementos intermedios.
tr:not(:first-child):not(:last-child)  //Selecciona todas las filas excepto la primera y la √∫ltima.
  :has()              //Es una pseudoclase m√°s reciente que selecciona un elemento si contiene otro elemento que coincida con el selector especificado. Aunque no es un reemplazo directo para :not(:first-child), ofrece una gran flexibilidad en ciertos escenarios

Pseudoclase CSS (y Pseudoelemento) 
¬øQu√© es? Son palabras clave que se a√±aden a los selectores de CSS para indicar un estado o una posici√≥n especial de un elemento HTML, sin necesidad de modificar el HTML.
¬øPara qu√© se usa? Para aplicar estilos din√°micos a los elementos de una p√°gina web, como cambiar el color de un bot√≥n cuando pasas el rat√≥n por encima.
Contexto: Se usa exclusivamente en CSS para definir reglas de estilo.
Ejemplo:
:hover (pseudoclase): Aplica un estilo cuando el cursor se sit√∫a sobre un elemento.
::first-letter (pseudoelemento): Aplica un estilo solo a la primera letra de un elemento.
:first-child (pseudoclase): Selecciona el primer hijo de un elemento padre. 
En resumen
La expresi√≥n tr:not(:first-child) que mencionaste no es pseudoc√≥digo. Es un selector CSS que utiliza una pseudoclase (:not) y otra pseudoclase (:first-child) para seleccionar elementos de una forma muy espec√≠fica.

2.2  Mexclando ROLE y CSS
// Localiza la tabla por su rol y luego busca las filas, excluyendo la primera con CSS.
const filasDeDatos = page.getByRole('table').locator('tr:not(:first-child)');


‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

3. ü•â Localizadores Basados en Ruta (XPath)
XPath es poderoso, pero generalmente es lento y fr√°gil. Solo √∫salo si no hay otra opci√≥n.

Tipo	¬øQu√© le dices al Detective?	                                         Ejemplo de Uso
XPath	"Ve a la cuarta div del tercer section y busca el primer bot√≥n."     page.locator('//div[3]/section[1]/button[1]')

üó∫Ô∏è ¬øC√≥mo Localizar Cosas? (El Proceso)
Para encontrar el mejor localizador en tu p√°gina:

Inspeccionar: Usa las Herramientas de Desarrollador de tu navegador (clic derecho -> Inspeccionar) para ver el c√≥digo HTML del elemento que te interesa.

Buscar Identificadores: Primero, mira si el elemento tiene un atributo id (id="miBoton") o un atributo data-testid (que se agrega para la automatizaci√≥n). ¬°Estos son los mejores!

Probar Roles: ¬øEs un bot√≥n? ¬øEs un link? Busca el texto que el usuario ve (name: 'Comprar').

Escribir el C√≥digo:

Ejemplo Pr√°ctico:
Si el HTML es:  <button id="submit-btn" class="main-btn" role="button">Enviar</button>
Podr√≠as usar:
Localizador	        C√≥digo Playwright	                            Raz√≥n
getByRole (Mejor)	page.getByRole('button', { name: 'Enviar' })	Usa el texto que ve el usuario y el rol. Muy estable.
CSS ID	            page.locator('#submit-btn')	                    Usa el ID. R√°pido y √∫nico.
CSS Class	        page.locator('.main-btn')	                    Menos ideal, puede haber otras clases iguales.

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
üî• EXTRA TIP üî• POCM - Page Object Component Model
Cuando estas usando POM, defines todos los objetos (locators) en la clase POM, sin embargo puedes usar un archivo referenciado para los 
‚úîÔ∏è Elementos globales / comunes

Si tienes elementos que aparecen en todas las p√°ginas,
como:
header
sidebar
footer
navbar
modal reutilizable

componentes UI repetidos

Ah√≠ S√ç tiene sentido crear una clase separada llamada por ejemplo:

Header.ts
export class Header {
  constructor(private page: Page) {}

  readonly userMenu = this.page.locator('#user-menu');
  readonly logoutBtn = this.page.locator('#logout');

  async logout() {
    await this.userMenu.click();
    await this.logoutBtn.click();
  }
}


Y luego usarla DENTRO de las dem√°s p√°ginas:

class DashboardPage {
  header: Header;

  constructor(private page: Page) {
    this.header = new Header(page);
  }
}


Esto se llama Component Model o POCM (Page Object Component Model).